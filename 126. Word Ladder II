O(26kn) time, O(???) space
class Solution(object):
    def findLadders(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: List[List[str]]
        """
        
        wordSet = set(wordList)
        
        if endWord not in wordSet: return []
        
        prevMap = collections.defaultdict(list)
        cur = set([beginWord])
        lowercaseLetters = string.ascii_lowercase
        while cur:
            temp = set()
            for word in cur:
                for i in range(len(word)):
                    for c in lowercaseLetters:
                        if c == word[i]: continue
                        newWord = word[:i]+c+word[i+1:]
                        if newWord in wordSet:
                            prevMap[newWord].append(word)
                            temp.add(newWord)
            
            if not temp or endWord in temp: break
            
            for word in temp:
                wordSet.remove(word)
            
            cur = temp
        
        res = []
        def buildPath(word, path):
            if word == beginWord:
                res.append([word]+path[::-1])
                return
            
            if word not in prevMap: return
            
            for prevWord in prevMap[word]:
                buildPath(prevWord, path+[word])

        buildPath(endWord, [])

        return res


O(26kn) time, O(kn) space
class Solution(object):
    def findLadders(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: List[List[str]]
        """
        
        lowercase = string.ascii_lowercase
        hashTable = collections.defaultdict(set)
        cur = set([beginWord])
        wordSet = set(wordList)
        
        while cur:
            tmp = set()
            for word in cur:
                for idx in range(len(word)):
                    for char in lowercase:
                        newWord = word[:idx]+char+word[idx+1:]
                        if newWord in wordSet:
                            tmp.add(newWord)
                            hashTable[newWord].add(word)
            
            if endWord in tmp:
                break
            
            for word in tmp:
                wordSet.remove(word)
        
            cur = tmp
        
        res = []
        myStack = [(endWord, [endWord])]
        while myStack:
            word, trace = myStack.pop()
            for prevWord in hashTable[word]:
                if prevWord == beginWord:
                    trace.append(beginWord)
                    res.append(trace[::-1])
                else:
                    myStack.append((prevWord, trace+[prevWord]))
        
        return res
