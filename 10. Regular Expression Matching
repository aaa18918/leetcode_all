class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        
        if not s: return True if not p or self.restPIsValid(p) else False
        
        index_s, index_p = 0, 0
        p = self.compressP(p)
        len_s, len_p = len(s), len(p)
        
        while index_s < len_s and index_p < len_p:
            if p[index_p] == '.':
                if index_p+1 < len_p and p[index_p+1] != '*':
                    index_s, index_p = index_s+1, index_p+1
                elif index_p+1 < len_p and p[index_p+1] == '*':
                    for index in range(index_s, len_s+1):
                        if self.isMatch(s[index:], p[index_p+2:]): return True
                    return False
                else:
                    index_s, index_p = index_s+1, index_p+1
            elif p[index_p] == '*':
                return False
            else:
                if s[index_s] != p[index_p]:
                    if index_p+1 < len_p and p[index_p+1] == '*':
                        index_p += 2
                    else:
                        return False
                else:
                    if index_p+1 < len_p and p[index_p+1] == '*':
                        if self.isMatch(s[index_s:], p[index_p+2:]): return True
                        repeat_char = p[index_p]
                        while index_s < len_s and s[index_s] == repeat_char:
                            if self.isMatch(s[index_s+1:], p[index_p+2:]): return True
                            index_s += 1
                        return False
                    else:
                        index_s, index_p = index_s+1, index_p+1

        return True if index_s == len_s and (index_p == len_p or self.restPIsValid(p[index_p:])) else False
    
    def restPIsValid(self, p):
        if len(p)%2 != 0: return False
        for index in range(0, len(p), 2):
            if p[index] != '*' and p[index+1] == '*':
                continue
            else:
                return False
        return True
    
    def compressP(self, p):
        if len(p) < 3: return p
        result = list(p[:3])
        
        for char in p[3:]:
            if char == '*' and result[-2] == '*' and result[-1] == result[-3]:
                result.pop()
            else:
                result.append(char)
        
        return ''.join(result)


class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        
        len_s, len_p = len(s), len(p)
        
        dp = [[False]*(len_p+1) for _ in range(len_s+1)]
        dp[0][0] = True
        
        for j in range(1, len_p+1):
            if j > 1 and p[j-1] == '*':
                dp[0][j] = dp[0][j-2]
        
        for i in range(1, len_s+1):
            for j in range(1, len_p+1):
                if s[i-1] == p[j-1] or p[j-1] == '.':
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] != '*':
                    dp[i][j] = False
                else:
                    if j == 1:
                        dp[i][j] = False
                    elif s[i-1] != p[j-2] and p[j-2] != '.':
                        dp[i][j] = dp[i][j-2]
                    else:
                        dp[i][j] = dp[i][j-2] or dp[i][j-1] or dp[i-1][j]
        
        return dp[len_s][len_p]
