https://leetcode.com/problems/top-k-frequent-elements/import heapq

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        
        hash_table = {}
        
        for number in nums:
            if number not in hash_table:
                hash_table[number] = 1
            else:
                hash_table[number] += 1
        
        keys, values = hash_table.keys(), hash_table.values()
        
        #min heap
        min_heap = []
        
        for index in range(0, k):
            heapq.heappush(min_heap, (values[index], keys[index]))
        
        for index in range(k, len(values)):
            if values[index] > min_heap[0][0]:
                heapq.heappop(min_heap)
                heapq.heappush(min_heap, (values[index], keys[index]))
            
        result = []
        for item in min_heap:
            result.append(item[1])
        
        return result

from collections import Counter

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        
        counter = Counter(nums)
        return [num_and_frequent[0] for num_and_frequent in counter.most_common(k)]

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        
        num_and_frequent_table = {}
        
        for num in nums:
            if num not in num_and_frequent_table:
                num_and_frequent_table[num] = 0
            num_and_frequent_table[num] += 1
        
        frequent_num_pairs = zip(num_and_frequent_table.values(), num_and_frequent_table.keys())
        
        min_heap = frequent_num_pairs[:k]
        heapq.heapify(min_heap)
        for frequent_num_pair in frequent_num_pairs[k:]:
            frequent, num = frequent_num_pair
            if frequent > min_heap[0][0]:
                heapq.heappushpop(min_heap, frequent_num_pair)

        return [frequent_num_pair[1] for frequent_num_pair in min_heap]

class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """

        counter_of_num_occurrence = {}
        for num in nums:
            if num not in counter_of_num_occurrence:
                counter_of_num_occurrence[num] = 0
            counter_of_num_occurrence[num] += 1

        num_and_frequent = zip(counter_of_num_occurrence.values(), counter_of_num_occurrence.keys())

        def topKFrequentNumber(items, k):
            pivot = items[0][0]
            index, left, right = 0, 0, len(items)-1
            
            while left <= index <= right:
                if items[index][0] > pivot:
                    items[left], items[index] = items[index], items[left]
                    left += 1
                elif items[index][0] < pivot:
                    items[right], items[index] = items[index], items[right]
                    right -= 1
                else:
                    index += 1

            if k > right+1:
                return [item[1] for item in items[:right+1]] + topKFrequentNumber(items[right+1:], k-right-1)
            elif k < left:
                return topKFrequentNumber(items[:left], k)
            else:
                return [item[1] for item in items[:k]]

        return topKFrequentNumber(num_and_frequent, k)


class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        
        counter = [(t, val) for val, t in collections.Counter(nums).iteritems()]
        
        def quickSelection(counter, k):
            p = counter[0][0]
            left, right, idx = 0, len(counter)-1, 0
            
            while left <= idx <= right:
                if counter[idx][0] > p:
                    counter[left], counter[idx] = counter[idx], counter[left]
                    left += 1
                elif counter[idx][0] < p:
                    counter[idx], counter[right] = counter[right], counter[idx]
                    right -= 1
                else:
                    idx += 1
            
            if k < left:
                return quickSelection(counter[:left], k)
            elif k == left:
                return counter[:left]
            elif k <= idx:
                return counter[:k]
            else:
                return counter[:idx]+quickSelection(counter[idx:], k-idx)
        
        return [val for t, val in quickSelection(counter, k)]


class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        
        def quickSelection(nums, k):
            if not nums or k <= 0: return []
            
            pivot = nums[0][1]
            left, right, idx = 0, len(nums)-1, 0
            while left <= idx <= right:
                if nums[idx][1] > pivot:
                    nums[idx], nums[left] = nums[left], nums[idx]
                    left, idx = left+1, idx+1
                elif nums[idx][1] < pivot:
                    nums[idx], nums[right] = nums[right], nums[idx]
                    right -= 1
                else:
                    idx += 1
            
            if k < left:
                return quickSelection(nums[:left], k)
            elif k <= idx:
                return nums[:k]
            else:
                return nums[:idx]+quickSelection(nums[idx:], k-idx)
        
        counter = [(num, count) for num, count in collections.Counter(nums).iteritems()]
        return [num for num, count in quickSelection(counter, k)]
