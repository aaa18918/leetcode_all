O(n) time, O(1) space
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        
        if not root: return 0
        
        def myDFS(node, length):
            left, right = 0, 0
            if node.left:
                if node.val-node.left.val == -1:
                    left = myDFS(node.left, length+1)
                else:
                    left = myDFS(node.left, 1)
                
            if node.right:
                if node.val-node.right.val == -1:
                    right = myDFS(node.right, length+1)
                else:
                    right = myDFS(node.right, 1)
            
            return max(length, left, right)
        
        return myDFS(root, 1)


O(n) time, O(lgn) space
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        
        if not root: return 0
        
        res, my_stack = 0, [(root, 1)]
        
        while my_stack:
            node, count = my_stack.pop()
            res = max(count, res)
            if node.left:
                if node.left.val-node.val == 1:
                    my_stack.append((node.left, count+1))
                else:
                    my_stack.append((node.left, 1))

            if node.right:
                if node.right.val-node.val == 1:
                    my_stack.append((node.right, count+1))
                else:
                    my_stack.append((node.right, 1))
        
        return res
