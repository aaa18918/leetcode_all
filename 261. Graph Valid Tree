O(n) time, O(n) space
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        
        adj = collections.defaultdict(list)
        for edge in edges:
            adj[edge[0]].append(edge[1])
            adj[edge[1]].append(edge[0])
        
        visited = [0 for i in range(n)]
        
        def myDFS(cur, prev):
            if visited[cur] == 1:
                return False
            
            visited[cur] = 1
            for num in adj[cur]:
                if num != prev and not myDFS(num, cur):
                    return False
            
            return True
        
        for i in range(n):
            if visited[i] != 1 and not myDFS(i, -1):
                return False
        
        return len(edges) == n-1



O(nlgn) time, O(n) space
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        
        if len(edges) != n-1:
            return False
        
        parent = [-1 for _ in range(n)]
        
        def find(x):
            depth = 0
            while parent[x] != -1:
                depth, x = depth+1, parent[x]
            
            return depth, x
        
        def union(left, right):
            depth_left, parent_left = find(left)
            depth_right, parent_right = find(right)
            
            if parent_left == parent_right != -1:
                return False
            
            if depth_left < depth_right:
                parent[parent_left] = parent_right
            else:
                parent[parent_right] = parent_left
            
            return True
        
        for edge in edges:
            if not union(edge[0], edge[1]):
                return False
        
        return True
