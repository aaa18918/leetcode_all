O(n) time, O(lgn) space
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        stack, cur = [], root
        pre = None
        
        while stack or cur:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                p = stack.pop()
                if pre and pre.val >= p.val:
                    return False
                
                pre = p
                cur = p.right
            
        return True

import sys

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def helper(root, range):
            if not root:
                return True
            
            if root.val <= range[0] or root.val >= range[1]:
                return False
            
            return helper(root.left, [range[0], min(root.val, range[1])]) and helper(root.right, [max(range[0], root.val), range[1]])
        
        return helper(root, [-sys.maxint-1, sys.maxint])

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        convertedList = self.convertBTToList(root)
        for index in range(1, len(convertedList)):
            if convertedList[index] <= convertedList[index-1]:
                return False
        
        return True
    
    def convertBTToList(self, root):
        if not root:
            return []
        
        return self.convertBTToList(root.left)+[root.val]+self.convertBTToList(root.right)


# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def helper(root, range):
            if not root:
                return True
            
            if root.val <= range[0] or root.val >= range[1]:
                return False
            
            return helper(root.left, [range[0], root.val]) and helper(root.right, [root.val, range[1]])
        
        return helper(root, [-sys.maxint-1, sys.maxint])


# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def myDFS(node, lower, upper):
            if not node: return True
            if node.val <= lower or node.val >= upper: return False
            
            return myDFS(node.left, lower, node.val) and myDFS(node.right, node.val, upper)
        
        return myDFS(root, -sys.maxint-1, sys.maxint)


# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        if not root: return True
        
        my_stack = []
        node, prev = root, None
        while node:
            my_stack.append(node)
            node = node.left
        
        while my_stack:
            if not node:
                node = my_stack.pop()
                if prev and node.val <= prev.val: return False
            
            prev = node
            node = node.right
            while node:
                my_stack.append(node)
                node = node.left
        
        return True
