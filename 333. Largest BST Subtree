# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def largestBSTSubtree(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """

        def myDFS(root):
            if not root: return True, None, None, 0
            
            is_left_bst, left_smallest_node, left_largest_node, left_node_num = myDFS(root.left)
            is_right_bst, right_smallest_node, right_largest_node, right_node_num = myDFS(root.right)

            if is_left_bst and is_right_bst:
                if root.left and root.right:
                    if left_largest_node.val < root.val < right_smallest_node.val:
                        return True, left_smallest_node, right_largest_node, left_node_num+right_node_num+1
                    else:
                        return False, None, None, max(left_node_num, right_node_num)
                elif root.left:
                    if root.val > left_largest_node.val:
                        return True, left_smallest_node, root, left_node_num+1
                    else:
                        return False, None, None, left_node_num
                elif root.right:
                    if root.val < right_smallest_node.val:
                        return True, root, right_largest_node, right_node_num+1
                    else:
                        return False, None, None, right_node_num
                else:
                    return True, root, root, 1
            else:
                return False, None, None, max(left_node_num, right_node_num)
        
        return myDFS(root)[3]

