O(n) time, O(lgn) space
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        prev, my_stack, p = None, [], root
        while p:
            my_stack.append(p)
            p = p.left
        
        while my_stack:
            p = my_stack.pop()
            if prev and prev.val >= p.val:
                return False
            
            prev = p
            
            p = p.right
            while p:
                my_stack.append(p)
                p = p.left
        
        return True


import sys

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def helper(root, range):
            if not root:
                return True
            
            if root.val <= range[0] or root.val >= range[1]:
                return False
            
            return helper(root.left, [range[0], min(root.val, range[1])]) and helper(root.right, [max(range[0], root.val), range[1]])
        
        return helper(root, [-sys.maxint-1, sys.maxint])

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        convertedList = self.convertBTToList(root)
        for index in range(1, len(convertedList)):
            if convertedList[index] <= convertedList[index-1]:
                return False
        
        return True
    
    def convertBTToList(self, root):
        if not root:
            return []
        
        return self.convertBTToList(root.left)+[root.val]+self.convertBTToList(root.right)


# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def helper(root, range):
            if not root:
                return True
            
            if root.val <= range[0] or root.val >= range[1]:
                return False
            
            return helper(root.left, [range[0], root.val]) and helper(root.right, [root.val, range[1]])
        
        return helper(root, [-sys.maxint-1, sys.maxint])


# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def myDFS(node, lower, upper):
            if not node: return True
            if node.val <= lower or node.val >= upper: return False
            
            return myDFS(node.left, lower, node.val) and myDFS(node.right, node.val, upper)
        
        return myDFS(root, -sys.maxint-1, sys.maxint)
