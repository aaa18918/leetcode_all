from exceptions import ValueError

class TrieNode(object):
    def __init__(self):
        self.childs = {}
        self.is_word = False

class Trie(object):
    def __init__(self):
        self.root = TrieNode()
    
    def getRoot(self):
        return self.root
    
    def insertWord(self, word):
        p = self.root
        for c in word:
            if c not in p.childs:
                p.childs[c] = TrieNode()
            p = p.childs[c]
        if word: p.is_word = True
    
    def deleteWord(self, word):
        p, parents_queue = self.root, []
        for c in word:
            parents_queue.append((c, p))
            if c not in p.childs:
                raise ValueError("The word: {} does not exist in the Trie.".format(word))
            
            p = p.childs[c]
        
        p.is_word = False
        while parents_queue and not p.is_word and not p.childs:
            c, parent = parents_queue.pop()
            del parent.childs[c]
            p = parent

class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        
        if not board: return []
        
        trie = Trie()
        root = trie.getRoot()
        
        for w in words:
            trie.insertWord(w)
        
        m, n = len(board), len(board[0])
        res, visited, diff = [], set(), [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        def myDFS(word, node, x, y):
            visited.add((x, y))
            if node.is_word:
                res.append(word)
                trie.deleteWord(word)
            
            for d in diff:
                new_x, new_y = x+d[0], y+d[1]
                if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and board[new_x][new_y] in node.childs:
                    myDFS(word+board[new_x][new_y], node.childs[board[new_x][new_y]], new_x, new_y)
            
            visited.remove((x, y))
            
        
        for i in range(m):
            for j in range(n):
                if board[i][j] in root.childs:
                    myDFS(board[i][j], root.childs[board[i][j]], i, j)
        
        return res


from exceptions import ValueError

class TrieNode(object):
    def __init__(self):
        self.childs = {}
        self.is_word = False

class Trie(object):
    def __init__(self):
        self.root = TrieNode()
    
    def getRoot(self):
        return self.root
    
    def insertWord(self, word):
        p = self.root
        for c in word:
            if c not in p.childs:
                p.childs[c] = TrieNode()
            p = p.childs[c]
        if word: p.is_word = True

class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        
        if not board: return []
        
        trie = Trie()
        root = trie.getRoot()
        
        for w in words:
            trie.insertWord(w)
        
        m, n = len(board), len(board[0])
        res, visited, diff = set(), set(), [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        def myDFS(word, node, x, y):
            visited.add((x, y))
            if node.is_word:
                res.add(word)
            
            for d in diff:
                new_x, new_y = x+d[0], y+d[1]
                if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited and board[new_x][new_y] in node.childs:
                    myDFS(word+board[new_x][new_y], node.childs[board[new_x][new_y]], new_x, new_y)
            
            visited.remove((x, y))
            
        
        for i in range(m):
            for j in range(n):
                if board[i][j] in root.childs:
                    myDFS(board[i][j], root.childs[board[i][j]], i, j)
        
        return list(res)


class TrieNode(object):
    def __init__(self):
        self.is_word = False
        self.children = [None for _ in range(26)]

class Trie(object):
    def __init__(self):
        self.root = TrieNode()
    
    def getRoot(self):
        return self.root
    
    def insertWord(self, word):
        if not word: return
        
        p = self.root
        for c in word:
            if not p.children[ord(c)-ord('a')]:
                p.children[ord(c)-ord('a')] = TrieNode()
            p = p.children[ord(c)-ord('a')]
        
        p.is_word = True
    
    def deleteWord(self, word):
        if not word: return
        
        p = self.root
        path_stack = []
        for c in word:
            path_stack.append((p, c))
            p = p.children[ord(c)-ord('a')]
        
        p.is_word = False
        while path_stack and not p.is_word and not filter(lambda x: x is not None, p.children):
            parent, c = path_stack.pop()
            parent.children[ord(c)-ord('a')] = None
            p = parent

class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        
        if not board or not words: return []
        
        trie = Trie()
        for word in words:
            trie.insertWord(word)
        
        res = []
        visited = set()
        diff = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        m, n = len(board), len(board[0])
        def myDFS(word, node, x, y):
            if node.is_word:
                res.append(word)
                trie.deleteWord(word)
            
            visited.add((x, y))
            for d in diff:
                new_x, new_y = x+d[0], y+d[1]
                if 0 <= new_x < m and 0 <= new_y < n and (new_x, new_y) not in visited:
                    child_idx = ord(board[new_x][new_y])-ord('a')
                    if node.children[child_idx]:
                        myDFS(word+board[new_x][new_y], node.children[child_idx], new_x, new_y)
            
            visited.remove((x, y))
        
        root = trie.getRoot()
        for i in range(m):
            for j in range(n):
                child_idx = ord(board[i][j])-ord('a')
                if root.children[child_idx]:
                    myDFS(board[i][j], root.children[child_idx], i, j)
        
        return res
