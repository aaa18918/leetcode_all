O(klgn) time average, O(n) time worst, O(lgn) space average, O(n) space worst
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def closestKValues(self, root, target, k):
        """
        :type root: TreeNode
        :type target: float
        :type k: int
        :rtype: List[int]
        """
        
        def appendFollowingNodes(node, l, is_predecessor):
            node = node.left if is_predecessor else node.right
            
            while node:
                l.append(node)
                node = node.right if is_predecessor else node.left
        
        predecessor, successor = [], []
        
        node = root
        while node:
            if node.val == target:
                predecessor.append(node)
                successor.append(node)
                break
            elif node.val < target:
                predecessor.append(node)
                node = node.right
            else:
                successor.append(node)
                node = node.left
        
        res = []
        if node and node.val == target:
            res.append(node.val)
            
            node = predecessor.pop()
            appendFollowingNodes(node, predecessor, True)
            
            node = successor.pop()
            appendFollowingNodes(node, successor, False)
            
            k -= 1
        
        while k > 0:
            if predecessor and successor:
                if target-predecessor[-1].val < successor[-1].val-target:
                    node = predecessor.pop()
                    res.append(node.val)
                    
                    appendFollowingNodes(node, predecessor, True)
                else:
                    node = successor.pop()
                    res.append(node.val)
                    
                    appendFollowingNodes(node, successor, False)
            elif predecessor:
                node = predecessor.pop()
                res.append(node.val)
                
                appendFollowingNodes(node, predecessor, True)
            else:
                node = successor.pop()
                res.append(node.val)
                
                appendFollowingNodes(node, successor, False)
            
            k -= 1
        
        return res
