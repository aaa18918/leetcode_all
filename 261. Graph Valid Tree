O(n) time, O(n) space
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        
        edges = set(map(tuple, edges))
        
        if len(edges) != n-1: return False
        
        visited = [0 for _ in range(n)]
        adjacency_list = collections.defaultdict(list)
        for edge in edges:
            adjacency_list[edge[0]].append(edge[1])
            adjacency_list[edge[1]].append(edge[0])
        
        def myDFS(num, parent):
            if visited[num] == 1: return True
            if visited[num] == -1: return False
            
            visited[num] = -1
            for adjacent_num in adjacency_list[num]:
                if adjacent_num != parent and not myDFS(adjacent_num, num):
                    return False
            visited[num] = 1
            return True
        
        for num in adjacency_list.iterkeys():
            if not myDFS(num, -1):
                return False
        return True


O(nlgn) time, O(n) space
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        
        if len(edges) != n-1: return False
        
        nums = [-1 for _ in range(n)]
        
        def find(num):
            depth = 1
            while nums[num] != -1:
                depth, num = depth+1, nums[num]
            return depth, num
        
        for edge in edges:
            depth_x, x = find(edge[0])
            depth_y, y = find(edge[1])
            
            if x == y:
                return False
            
            if depth_x < depth_y:
                nums[x] = y
            else:
                nums[y] = x
        
        return True
