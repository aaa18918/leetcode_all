O(klgn) time average, O(n) time worst, O(lgn) space average, O(n) space worst
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def closestKValues(self, root, target, k):
        """
        :type root: TreeNode
        :type target: float
        :type k: int
        :rtype: List[int]
        """
        
        predecessor, successor  = [], []
        p = root
        while p:
            if p.val == target:
                predecessor.append(p)
                break
            elif p.val < target:
                predecessor.append(p)
                p = p.right
            else:
                p = p.left
        
        p = root
        while p:
            if p.val == target:
                successor.append(p)
                break
            elif p.val < target:
                p = p.right
            else:
                successor.append(p)
                p = p.left
        
        res = []
        if predecessor and successor and predecessor[-1].val == successor[-1].val:
            node = predecessor.pop()
            res.append(node.val)
            successor.pop()
            
            p = node.left
            while p:
                predecessor.append(p)
                p = p.right
            
            p = node.right
            while p:
                successor.append(p)
                p = p.left
            
            k -= 1
        
        while k > 0 and (predecessor or successor):
            if predecessor and successor:
                if target-predecessor[-1].val < successor[-1].val-target:
                    node = predecessor.pop()
                    res.append(node.val)
                    
                    node = node.left
                    while node:
                        predecessor.append(node)
                        node = node.right
                else:
                    node = successor.pop()
                    res.append(node.val)
                    
                    node = node.right
                    while node:
                        successor.append(node)
                        node = node.left
            elif predecessor:
                node = predecessor.pop()
                res.append(node.val)
                
                node = node.left
                while node:
                    predecessor.append(node)
                    node = node.right
            else:
                node = successor.pop()
                res.append(node.val)
                
                node = node.right
                while node:
                    successor.append(node)
                    node = node.left
            
            k -= 1
        
        return res
